#!/bin/bash

set -Eeuo pipefail


USAGE="do-backup [-c path] [--dry-run]"

usage() {
    echo "usage: ${USAGE}"
}

help() {
cat <<help
DESCRIPTION

    A script that orchestrates incremental backups. Backups are parameterized
    by parameters provided via a yaml config file passed with the -c flag.
    Config files are of the following form:

        path: "/path/to/incremental-backup"
        src: "/path/to/src/of/incremental/backup"
        dst: "/path/to/dst/of/incremental/backup"
        filters:   (optional, but both are required if block is used)
          type: "type of rsync filter"
          file: "path to rsync filter file
        args: additional flags to pass to rsync (optional)
        keep: "keep # incremental backups" (optional)

    If no file is passed via -c, the script will look for the file
    $HOME/.config/backup/config.yaml. If no such file exists, the script will
    exit.

USAGE

    ${USAGE}

OPTIONS

    -c, --config    optional; a path to a yaml file that parameterizes backups;
                    if not provided, the script tries to use default of 
                    $HOME/.config/backup/config.yaml
    --dry-run       optional; indicates that the script should print hypotheical
                    results to the console, but make no state changes
    -h, --help      display this message

help
}


CONFIG="${HOME}/.config/backup/config.yaml"
DRY_RUN=""

while [[ $# -gt 0 ]]; do
  case $1 in
    -c|--config)
      CONFIG="${2}"
      shift
      shift
      ;;
    --dry-run)
      DRY_RUN="true"
      shift
      ;;
    -h|--help)
      help
      exit 0
      ;;
    *|-*|--*)
      usage
      exit 1
      ;;
  esac
done

if [[ -z "${CONFIG}" ]]; then
    echo "No config found at ${CONFIG}; exiting"
    exit 0
fi

# extract args from config file; no need for validation (besides keep), as the
# downstream script will do that for us; note: the somewhat awkward looking "//"
# syntax is how we default to empty string instead of "null"s if optional 
# parameters are omitted

SCRIPT_PATH="$(yq ".path" "${CONFIG}")"
SOURCE_PATH="$(yq ".src" "${CONFIG}")"
BACKUP_PARENT="$(yq ".dst" "${CONFIG}")"
FILTER_TYPE="$(yq ".filters.type // \"\"" "${CONFIG}")"
FILTER_FILE="$(yq ".filters.file // \"\"" "${CONFIG}")"
EXTRA_ARGS="$(yq ".args // \"\"" "${CONFIG}")"
KEEP="$(yq ".keep // \"\"" "${CONFIG}")"

if [[ -n "${KEEP}" && "${KEEP}" -lt 1 ]]; then
    echo "keep must be > 0"
    exit 1
fi

# build up command based on presence of args in config

CMD="${SCRIPT_PATH}"
CMD="${CMD} $([[ -z ${SOURCE_PATH}   ]] && echo "" || echo "-s ${SOURCE_PATH}")"
CMD="${CMD} $([[ -z ${BACKUP_PARENT} ]] && echo "" || echo "-d ${BACKUP_PARENT}")"
CMD="${CMD} $([[ -z ${FILTER_TYPE}   ]] && echo "" || echo "-t ${FILTER_TYPE}")"
CMD="${CMD} $([[ -z ${FILTER_FILE}   ]] && echo "" || echo "-f ${FILTER_FILE}")"
CMD="${CMD} $([[ -z ${EXTRA_ARGS}    ]] && echo "" || echo "-a ${EXTRA_ARGS}")"
CMD="${CMD} $([[ "${DRY_RUN}" == "true" ]] && echo "--dry-run" || echo "")"

# exec

eval "${CMD}"

# remove oldest backup if the number of backups exceeds the threshold specified
# by keep; a few assumptions about this:
#
# 1) that there are no files/dirs in $BACKUP_PARENT except those managed by the
#    incremental backup script (i.e.: backup dirs and the "latest" link)
# 2) that the "latest" link's name is hardcoded
# 3) that we don't have to worry about concurrent executions of the incremental
#    backup script, so we only need to potentially delete one backup dir at a time
# 4) we don't need to explicitly respect the --dry-run flag, as no backup dir
#    should have been created by the backup script if the --dry-run flag is passed
#    and respected

BACKUPS_LS="$(ls "${BACKUP_PARENT}" | grep -v latest | sort)"
NUM_BACKUPS="$(echo "${BACKUPS_LS}" | wc -l)"

if [[ "${NUM_BACKUPS}" -le "${KEEP}" ]]; then
    exit 0
fi

OLDEST="${BACKUP_PARENT}/$(echo "${BACKUPS_LS}" | head -1)"
rm "${OLDEST}"

