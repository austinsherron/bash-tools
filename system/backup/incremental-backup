#!/bin/bash

set -Eeuo pipefail


USAGE="do-backup -s path -d path [-t filter-type -f path] [-a flags]"

usage() {
    echo "usage: ${USAGE}"
}

help() {
cat <<help
DESCRIPTION

    A script that uses rsync to perform incremental backups of a source, -s, to
    a destination, -d. Default rsync flags are "aAXp". Additional flags can be
    passed to rsync via -a. A file containing filters can be passed to rsync via
    -f along with a keyword indicating the rsync filter type via -t.

USAGE

    ${USAGE}

OPTIONS

    -s, --src           required; the path to the dir being backed up
    -d, --dst           required; the path to the parent of the backup dir
    -t, --filter-type   optional, must be passed w/ -f; the type of rsync filters
                        to apply
    -f, --filter-file   optional, must be passed w/ -t; a path to a file that
                        contains rsync filters
    -a, --args          optional; additional rsync flags
    --dry-run           optional; indicates that the script should print hypotheical
                        results to the console, but make no state changes
    -h, --help          display this message
help
}


SOURCE_PATH=""
BACKUP_PARENT=""
FILTER_TYPE=""
FILTER_FILE=""
EXTRA_ARGS=""
DRY_RUN=""

FILTERS=""
ARGS="-aAXp"

while [[ $# -gt 0 ]]; do
  case $1 in
    -s|--source)
      SOURCE_PATH="${2}"
      shift
      shift
      ;;
    -d|--dest)
      BACKUP_PARENT="${2}"
      shift
      shift
      ;;
    -t|--filter-type)
      FILTER_TYPE="${2}"
      shift
      shift
      ;;
    -f|--filter-file)
      FILTER_FILE="${2}"
      shift
      shift
      ;;
    -a|--args)
      EXTRA_ARGS="${2}"
      shift
      shift
      ;;
    --dry-run)
      DRY_RUN="--dry-run"
      shift
      ;;
    -h|--help)
      help
      exit 0
      ;;
    *|-*|--*)
      usage
      exit 1
      ;;
  esac
done

## validate args

if [[ -z "${SOURCE_PATH}" ]]; then
    echo "-s|--source is required"
    exit 1
fi

if [[ -z "${BACKUP_PARENT}" ]]; then
    echo "-d|--dest is required"
    exit 1
fi

if [[ -z "${FILTER_TYPE}"  ]] && [[ -n "${FILTER_FILE}" ]]; then
    echo "both -t|--filter-type and -f|--filter-file must be specified"
    exit 1
fi

if [[ -n "${FILTER_TYPE}"  ]] && [[ -z "${FILTER_FILE}" ]]; then
    echo "both -t|--filter-type and -f|--filter-file must be specified"
    exit 1
fi

## construct args

if [[ -n "${FILTER_TYPE}" ]]; then
    FILTERS="--filter=${FILTER_TYPE} ${FILTER_FILE}"
fi

if [[ -n "${EXTRA_ARGS}" ]]; then
    ARGS="${ARGS}${EXTRA_ARGS}"
fi

## construct internal script args

DATETIME="$(date '+%Y-%m-%d_%H:%M:%S')"
BACKUP_PATH="${BACKUP_PARENT}/${DATETIME}"
LATEST_LINK="${BACKUP_PARENT}/latest"
# only include "--link-dest" if "latest" link exists, i.e.: if this isn't the first run
LINK_DEST="$([[ -d "${LATEST_LINK}" ]] && echo "--link-dest=${LATEST_LINK}" || echo "")"

## trap execution errors and perform any necessary cleanup

trap 'cleanup $? $LINENO' ERR

cleanup() {
    echo "Error encountered: (${1}) on ${2}"
    echo "Cleaning up..."

    # remove the newest backup; it might be fine, but it's non-trivial (impossible)
    # to really know if the error we hit means the backup is borked
    if [[ -d "${BACKUP_PATH}" ]]; then
        echo "Removing new, potentially incomplete/corrupt backup at ${BACKUP_PATH}"
        rm -rf "${BACKUP_PATH}"
    fi

    # find the new latest backup to tag it as such
    LATEST_BACKUP="${BACKUP_PARENT}/$(ls "${BACKUP_PARENT}" | grep -v latest | sort -r | head -1)"

    # but exit if we can't find one
    if [[ ! -d "${LATEST_BACKUP}" ]]; then
        echo "Cannot find valid backup for latest link: ${LATEST_BACKUP} does not exist; exiting" 
        exit 0
    fi

    # if the latest link exists, just unlink and re-link, as it's quicker/easier
    # than checking it's validity and linking conditionally
    if [[ -d "${LATEST_LINK}" ]]; then
        unlink "${LATEST_LINK}" 
    fi

    ln -s "${LATEST_BACKUP}" "${LATEST_LINK}"
}


## exec

# make new backup dir
if [[ -n "${DRY_RUN}" ]]; then
    echo "mkdir ${BACKUP_PATH}"
else
    mkdir -p "${BACKUP_PATH}"
fi

# run rsync
if [[ -n "${DRY_RUN}" ]]; then
    echo "rsync ${ARGS} --delete ${LINK_DEST} ${DRY_RUN} ${FILTERS} ${SOURCE_PATH} ${BACKUP_PATH}"
fi

rsync "${ARGS}" --delete "${LINK_DEST}" "${DRY_RUN}" "${FILTERS}" "${SOURCE_PATH}" "${BACKUP_PATH}"

# unlink previous "latest" pointer, if it exists
if [[ -n "${DRY_RUN}" ]] && [[ -d "${LATEST_LINK}" ]]; then
    echo "unlink ${LATEST_LINK}"
elif [[ -d "${LATEST_LINK}" ]]; then
    unlink "${LATEST_LINK}"
fi

# create new "latest" pointer
if [[ -n "${DRY_RUN}" ]]; then
    echo "ln -s ${BACKUP_PATH} ${LATEST_LINK}"
else
    ln -s "${BACKUP_PATH}" "${LATEST_LINK}"
fi

