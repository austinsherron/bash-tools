#!/usr/bin/env bash

set -Eeuo pipefail

source /etc/profile.d/shared_paths.sh
source "${CODE_ROOT}/lib/bash/utils.sh"


USAGE="pkgmgr -p pkg -m mgr [-c cmd] [-f]"

usage() {
    echo "usage: ${USAGE}"
}

help() {
cat <<help
DESCRIPTION

    Central entry point for basic interactions w/ packages via apt, flatpak, and snap package managers. Available commands include:

        * check - checks if -p|--pkg is installed
        * search - searches all apt, flatpak, and snap for -p|--pkg
        * install - maps to install in all three package managers
        * update - maps to: apt "upgrade", flatpak "upgrade", snap "refresh"
        * remove - maps to: apt "remove", flatpak "uninstall", snap "remove"

    Packages are installed only if they aren't already, unless -f|--force is provided. Similarly, packages are only updated/removed if they already exist in the system.

USAGE

    ${USAGE}

OPTIONS

    -p, --pkg           the name of the package on which to perform an action; arguments/flags to package managers can be provided by providng quoted, multi-token strings
    -m, --mgr           must be one of "apt", "flatpak", or "snap"; the package manager to use
    -c, --cmd           optional, defaults to "install"; must be one of "check", "search", "install", "remove", or "update"; the cmd to run
    -a, --ask           optional; if provided, package managers will ask for confirmation (where supported, i.e.: snap doesn't support this feature)
    -f, --force         optional; if provided, install command will be executed even if package is already installed
    -s, --script        optional; the name of a script in "${SCRIPTS_ROOT}/install/[os]" to run; if provided, all params except -v|--verbose and -d|--dry-run will be ignored
    -d, --dry-run       optional; if present, no state changes are made
    -v, --verbose       optional; if present, print to stdout messages about the script's progress
    -h, --help          display this message
help
}

declare -A CMDS=([check]=1 [search]=1 [install]=1 [update]=1 [remove]=1)
declare -A APT=([install]="install" [remove]="remove" [update]="upgrade")
declare -A FP=([install]="install" [remove]="uninstall" [update]="upgrade")
declare -A SNAP=([install]="install" [remove]="remove" [update]="refresh")

PKG=""
MGR=""
CMD="install"
CONFIRM="-y"
ARGS=()
FORCE=""
SCRIPT=""
DRY_RUN=""

while [[ $# -gt 0 ]]; do
  case $1 in
    -p|--pkg)
      PKG="${2}"
      shift
      shift
      ;;
    -m|--mgr)
      MGR="${2}"
      shift
      shift
      ;;
    -a|--ask)
      CONFIRM=""
      shift
      ;;
    -f|--force)
      FORCE="true"
      shift
      ;;
    -s|--script)
      SCRIPT="${2}"
      shift
      shift
      ;;
    -d|--dry-run)
      DRY_RUN="true"
      shift
      ;;
    -v|--verbose)
      export ULOGGER_VERBOSE="true"
      shift
      ;;
    -h|--help)
      help
      exit 0
      ;;
     *)
      CMD="${1}"
      shift
      ;;
  esac
done


[[ -z "${ULOGGER_TYPE+x}" ]] && export ULOGGER_TYPE="pkg"
export ULOGGER_PREFIX="${CMD}"

__apt_cmd() {
    local cmd="${APT[${CMD}]}"

    ulogger info "running 'apt ${cmd} ${PKG}'"
    [[ -z "${DRY_RUN}" ]] && sudo apt update "${CONFIRM}" && sudo apt "${cmd}" ${PKG} ${ARGS[@]}
}

__flatpak_cmd() {
    local cmd="${FP[${CMD}]}"

    [[ "${PKG}" == *"."* ]] && [[ "${cmd}" == "install" ]] && PKG="flathub ${PKG}"
    ulogger info "running 'flatpak ${cmd} ${PKG}'"
    [[ -z "${DRY_RUN}" ]] && sudo flatpak "${cmd}" ${PKG} ${ARGS[@]}
}

__snap_cmd() {
    local cmd="${SNAP[${CMD}]}"

    ulogger info "running 'snap ${cmd} ${PKG} ${ARGS[*]}'"
    [[ -z "${DRY_RUN}" ]] && sudo snap "${cmd}" ${PKG} ${ARGS[@]}
}

__run_script() {
    local script_path="${SCRIPTS_ROOT}/install/$(os-type)/${SCRIPT}.sh"

    if [[ ! -f "${script_path}" ]]; then
        ulogger info "script=${script_path} doesn't exist; falling back to os-agnostic path"
        script_path="${SCRIPTS_ROOT}/install/generic/${SCRIPT}.sh"
        [[ ! -f "${script_path}" ]] && ulogger error "os-agnostic script=${script_path} doesn't exist" && exit 1
    fi

    ulogger info "running script=${script_path}"
    "${scripts_path}" && exit 0 || exit 1
}

# TODO: test this
[[ -n "${SCRIPT}" ]] && __run_script

if [[ -z "${PKG}" ]]; then
    ulogger error "-p|--pkg is required"
    exit 1
fi

if [[ -z "${MGR}" ]] && [[ "${CMD}" != "check" && "${CMD}" != "search" ]]; then
    ulogger error "-m|--mgr is required"
    exit 1
fi

if [[ -z "${CMDS[${CMD}]+x}" ]]; then
    CMDS_STR="$(echo "${!CMDS[*]}" | tr ' ' '|')"
    ulogger error "-c|--cmd must be one of ${CMDS_STR}"
    exit 1
fi

if [[ "${CMD}" == "search" ]]; then
    ulogger info "searching apt for ${PKG}" -s notify
    apt search "${PKG}"

    ulogger info "searching flatpak for ${PKG}" -s notify
    flatpak search "${PKG}"

    ulogger info "searching snap for ${PKG}" -s notify
    snap search "${PKG}"

    exit 0
fi

read -r -a PKG_ARR <<< "${PKG}"

if [[ "${#PKG_ARR[@]}" -eq 0 ]]; then
    ulogger info "-p|--pkg is required"
    exit 1
fi

PKG="${PKG_ARR[0]}"
ARGS+=("${PKG_ARR[@]:1}")
[[ -n "${CONFIRM}" ]] && [[ "${MGR}" != "snap" ]] && ARGS+=("${CONFIRM}")

[[ "${CMD}" == "check" ]] && [[ -n "${MGR}" ]] && CHECK_MGR="-m ${MGR}" || CHECK_MGR=""
{ check-pkg -p "${PKG}" ${CHECK_MGR}; RC="$?"; } || true

if [[ "${CMD}" == "check" ]]; then
    exit ${RC}
fi

# propagate unexpected error
if [[ ${RC} -eq 2 ]]; then
    exit 1
elif [[ ${RC} -eq 0 ]] && [[ "${CMD}" == "install" ]]; then
    ulogger info "${PKG} is already installed"
    [[ -z "${FORCE}" ]] && exit 0
    ulogger info "-f|--force option detected; forcing install"
elif [[ ${RC} -eq 1 ]] && [[ "${CMD}" != "install" ]]; then
    ulogger error "cannot ${CMD} package that isn't installed"
    exit 1
fi

case "${MGR}" in
    apt)
      __apt_cmd
      ;;
    flatpak)
      __flatpak_cmd
      ;;
    snap)
      __snap_cmd
      ;;
    *)
      ulogger error "-m|--mgr must be one of 'apt|flatpak|snap', not ${MGR}"
      exit 1
      ;;
esac

