#!/usr/bin/env bash
# shellcheck disable=SC2034

set -Eeuo pipefail

export VALIDATE_USE_ULOGGER=""
source "${LOCAL_LIB}/bash/args/validate.sh"
source "${LOCAL_LIB}/bash/log/utils.sh"


USAGE="log-env [-r [var]] [-s var] [-c var] {flags}"

usage() {
    echo "${USAGE}"
}

declare -A VARS=(
    [type]=ULOGGER_TYPE
    [prefix]=ULOGGER_PREFIX
    [disabled]=ULOGGER_DISABLED
    [strategy]=ULOGGER_STRATEGY
    [level_xfm]=ULOGGER_LEVEL_XFM
    [verbose]=ULOGGER_VERBOSE   # deprecated
)

declare -A VAR_DESCRIPTIONS=(
    [type]="     env: ULOGGER_TYPE"
    [prefix]="   env: ULOGGER_PREFIX"
    [disabled]=" env: ULOGGER_DISABLED"
    [strategy]=" env: ULOGGER_STRATEGY"
    [level_xfm]="env: ULOGGER_LEVEL_XFM"
    [verbose]="  env: ULOGGER_VERBOSE; note: DEPRECATED; use ULOGGER_LEVEL_XFM"
)

function __var_descriptions() {
    for var in "${!VAR_DESCRIPTIONS[@]}"; do
        local desc="${VAR_DESCRIPTIONS[${var}]}"
        echo "        ${var}        ${desc}"
    done
}

help() {
cat <<help
DESCRIPTION

    Utility for reading/setting ulogger environment variables. This script recognizes following variables:

        all              -r|--read, -c|--clear only - read/clear all env vars
$(__var_descriptions)

    Note: due to the nature of setting environment variables via scripts/commands, the --set flag should be used w/ an "eval" statement to actually update env vars in the caller's
    shell. For example:

        eval "\$(log-env -s type=install -s prefix=tools -f)"

USAGE

    ${USAGE}

OPTIONS

    -r, --read          optional, multi-valued, defaults to "all" if arg is omitted; specify vars to read; values are written to stdout in the form "var_name=value", unless --values is specified
    -s, --set           optional, multi-valued; specify vars to set in the following format: var_name=value
    -c, --clear         optional, multi-valued; specify vars to clear (i.e.: unset)

FLAGS

    -v, --values        optional; used w/ -r|--read; if provided, only write values to stdout, instead of "var_name=value"
    -f|--force          optional; used w/ -s|--set; if provided, overwrite existing environment values
    -h, --help          optional; display this message
help
}


READ=()
VALUES=""
declare -A SET=()
FORCE=""
CLEAR=()

function __process_read() {
    local key="${1:-all}"

    if [[ "${key}" == "all" ]]; then
        READ=("${VARS[@]}")
    else
        validate_one_of "env var" "${key}" "${!VARS[@]}" || return 1
        READ+=("${VARS[${key}]}")
    fi
}

function __process_set() {
    local var_str="${1:-}"

    if [[ ! "${var_str}" =~ [^[:space:]]+=[^[:space:]]+ ]]; then
        echo "[ERROR] to set env vars, provide vars/values in the form: var_key=value"
        return 1
    fi

    local key="${var_str%=*}"
    local val="${var_str#*=}"

    validate_one_of "env var" "${key}" "${!VARS[@]}" || return 1

    local var_name="${VARS[${key}]}"
    SET["${var_name}"]+="${val}"
}

function __process_clear() {
    local key="${1:-1}"

    if [[ "${key}" == "all" ]]; then
        CLEAR=("${VARS[@]}")
    else
        validate_one_of "env var" "${key}" "${!VARS[@]}" || return 1
        CLEAR+=("${VARS[${key}]}")
    fi
}

function __read_var() {
    local var="${1}"

    [[ -z "${VALUES}" ]] && echo -n "${var}=\""
    [[ -n "${!var+x}" ]] && echo -n "${!var}" || echo -n ""
    [[ -z "${VALUES}" ]] && echo -n "\""
    [[ -n "${!var+x}" ]] || [[ -z "${VALUES}" ]] && echo ""

    return 0
}

function __handle_read() {
    for var in "${READ[@]}"; do
        __read_var "${var}" || return 1
    done
}

function __set_var() {
    local var="${1}"
    local val="${2}"

    if [[ -z "${!var+x}" || -n "${FORCE}" ]]; then
        echo "export ${var}=${val}"
    fi
}

function __handle_set() {
    for var in "${!SET[@]}"; do
        val="${SET[${var}]}"
        __set_var "${var}" "${val}" || return 1
    done
}

function __clear_var() {
    local var="${1}"

    if [[ -n "${!var+x}" ]]; then
        echo "unset ${var}"
    fi
}

function __handle_clear() {
    for var in "${CLEAR[@]}"; do
        __clear_var "${var}" || return 1
    done
}

while [[ $# -gt 0 ]]; do
  case $1 in
    -r|--read )
        __process_read "${2:-}" || exit 1 ; [[ -n "${2:-}" ]] && shift ; shift ;;
    -v|--values)
        VALUES="true" ; shift ;;
    -s|--set)
        __process_set "${2:-}" || exit 1 ; shift ; shift ;;
    -f|--force)
        FORCE="true" ; shift ;;
    -c|--clear)
        __process_clear "${2:-}" || exit 1 ; shift ; shift ;;
    -h|--help)
        help && exit 0 ;;
    *)
        "error: $(usage)" && exit 1 ;;
  esac
done


__handle_read || exit 1
__handle_set || exit 1
__handle_clear || exit 1

exit 0

