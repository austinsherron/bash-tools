#!/usr/bin/env bash

set -Eeuo pipefail


USAGE="usage: conf -p path  {-k key -v val [-r attr]} [--root yaml_path] [-a|-u|-w|-d] [--strict] [--verbose]"

usage() {
    echo "${USAGE}"
}

help() {
cat <<help
DESCRIPTION

    Read, add, update, and delete values from yaml configuration files. Behaviors can be specified via -a, -u, or -d. The default behavior is to read. Keys/values are 
    specified via -k, -v flags 

    Some behavioral notes:

      * When reading, values are written to stdout in the order in which -k args are specified
      * The last behavior specified is the one used.
      * -k, -v, and -r args can come in more or less any order, but must follow these rules:

        1) a -k must come before a corresponding -v/-r
        2) a single -k maps to a single -v/-r (i.e.: one -k, one -v, one -r)
        3) if multiple -v values are specified before a -v or -r, -k/-v and -k/-r pairs are associated based on their relative order w/in their respective param group; 

    An example for the last point:
      
      Args:

        -k k1 -k k2 -k k3 -v v1 -k k4 -r r1 -v v2 -v v3 -r r2 -r r3 -r r4 -v v4 

      Result in pairs:

          (k1,v1) (k2,v2) (k3,v3) (k4,v4), (k1,r1) (k2,r2) (k3,r3) (k4,r4)

    Warning: this script is still a WIP. To come:

      * Fix or remove -a/-u
      * Support for --strict (or potentially remove)

USAGE

    ${USAGE}

OPTIONS

    -p,  --path     path to the config file
    -k,  --key      optional, multi-valued; key of config value to CRUD; should be yaml path in the format expected by yq; when used w/ -a, -u, or -w, each -k must have a
                    corresponding -v, and when used w/ --strict, a corresponding -r; -k, -v, and -r args can mostly come in any order, but -k args should come before
                    corresponding -v/-r args, and -k/-v and -k/-r pairs are matched based on relative order w/in each param group: the first -k gets matched w/ the first
                    -v/first -r, nth -k w/ the nth -v/nth -r, etc.
    -v,   --val     optional, multi-valued, each -v must correspond to a -k; config value to CUD; values are required for adds/updates and are optional for deletes (see
                    --strict); must provide one -v per -k, -v must come after -k, and the nth -v is associated w/ the nth -k
    -a,  --add      optional; if specified, add values -v* at the yaml paths specified by -k*
    -u,  --update   optional; if specified, update values found at -k* w/ attr values passed via -v*; if --strict is specified, additionally require a corresponding -r for
                    every -a (see --strict and -r|--replace)
    -r,  --rep      optional, multi-valued, each -r must correspond to a -k/-v; if --strict and -u are specified, an -r is required for each -a to update; if passed
                    but not needed, -r values are ignored w/o --strict and cause validation failures otherwise; must provide one -r per -k/-v, -r must come after -k, and
                    the nth -r is associated w/ the nth -k
    -w,  --write    optional; -a + -u: add or update values -v* at the yaml paths specified by -k*
    -d,  --delete   optional; if specified, delete values found at -i; if --strict is specified, require a corresponding -v for every value being deleted (see --strict)
    --strict        optional; if specified, update and deletes require existing values to be matched via -v* (for deletes) or -r* (for updates) before state changes are 
                    made; for examples, to delete "-k max_concurrency" w/ an existing value of "4", the caller needs to pass "-k max_concurrency -v 4" to the delete
                    call; continuing the example: to update max_concurrency to 6, the caller needs to pass "-k max_concurrency -v 6 -r 4"; additionally, this flag will
                    cause the script to return non-zero values if values exist for specified keys and the -u flag isn't specified w/ corresponding -v*/-r* values
    --root          optional; an optional root shared by all keys; useful for updated many deeply nested key/vals
    --verbose       optional; write progress/status messages to stdout
    -h, --help      display this message
help
}

KEYS=()
declare -A KVS=()
REP_KEYS=()
declare -A REP_KVS=()

KEY=""

CONFIG_PATH=""
BEHAVIOR="READ"
ROOT=""
STRICT=""
VERBOSE=""


log() {
    [[ -n "$VERBOSE" ]] && echo "${1}" || echo -n ""
}

track_key() {
    KEYS+=("$1")
    KVS+=(["$1"]="")

    log "Tracked key='$1'"
}

associate_kv_pair() {
    [[ "${#KEYS[@]}" -lt 1 ]] && "Error: no key for corresponding value" && exit 1

    local key="${KEYS[0]}"
    KEYS=("${KEYS[@]:1}")
    KVS["$key"]="$1"

    log "Associated key='$key' w/ value='$1'"
}

track_rep_key() {
    REP_KEYS+=("$1")
    REP_KVS+=(["$1"]="")
    
    log "Tracked rep_key='$1'"
}

associate_rep_kv_pair() {
    [[ "${#REP_KEYS[@]}" -lt 1 ]] && "Error: no rep key for corresponding value" && exit 1

    local rep_key="${REP_KEYS[0]}"
    REP_KEYS=("${REP_KEYS[@]:1:}")
    REP_KVS["$rep_key"]="$1"

    log "Associated rep_key='$rep_key' w/ value='$1'"
}


while [[ $# -gt 0 ]]; do
  case $1 in
    -p|--path)
      CONFIG_PATH="$2"
      shift
      shift
      ;;
    -k|--key)
      track_key "$2"
      track_rep_key "$2"
      shift
      shift
      ;;
    -v|--val)
      associate_kv_pair "$2"
      shift
      shift
      ;;
    -r|--rep)
      associate_rep_kv_pair "$2"
      shift
      shift
      ;;
    --root)
      ROOT="$2"
      shift
      shift
      ;;
    -a|--add)
      BEHAVIOR="ADD"
      shift
      ;;
    -u|--update)
      BEHAVIOR="UPDATE"
      shift
      ;;
    -w|--write)
      BEHAVIOR="WRITE"
      shift
      ;;
    -d|--delete)
      BEHAVIOR="DELETE"
      shift
      ;;
    # --strict)
    #   STRICT="true"
    #   shift
    #   ;;
    --verbose)
      VERBOSE="true"
      shift
      ;;
    -h|--help)
      help
      exit 0
      ;;
    *)
      usage
      exit 1
      ;;
  esac
done


full_key() {
    echo "${ROOT}${KEY}"
}

existing_val() {
    local yaml_path="$(full_key)"
    log "Reading value @ key='$yaml_path'"
    val="$(yq "$yaml_path" "${CONFIG_PATH}")"
    [[ "$val" == "null" ]] && echo "" || echo "$val"
}

new_val() {
    echo "${KVS["$KEY"]}"
}

write_val() {
    local to_write="$(new_val)"
    [[ -z "$to_write" ]] && echo "No value specified for key='$KEY'"  && exit 1

    local yaml_path="$(full_key)"
    log "$1 value='$to_write' @ key='$yaml_path'"

    yq -i "$yaml_path = \"$to_write\"" "${CONFIG_PATH}"
    log "Successfully $1 value"
}

delete_val() {
    local yaml_path="$(full_key)"
    log "Deleting value @ key='$yaml_path'"

    yq -i "del($yaml_path)" "${CONFIG_PATH}"
    log "Successfully deleted value"
}


if [[ -z "${CONFIG_PATH}" ]]; then
    echo "-p|--path is required"
    exit 1
fi

for KEY in "${!KVS[@]}"; do
    if [[ "$BEHAVIOR" == "READ" ]]; then
        existing_val
    elif [[ "$BEHAVIOR" == "DELETE" ]]; then
        delete_val
    elif [[ "$BEHAVIOR" == "WRITE" ]]; then
        write_val "Writing" "wrote"
    elif [[ "$BEHAVIOR" == "ADD" ]]; then
        [[ -z "$(existing_val)" ]] && write_val "Adding" "added" || log "Value already exists for $(full_key); nothing to do" && exit 0
    elif [[ "$BEHAVIOR" == "UPDATE" ]]; then
        [[ -n "$(existing_val)" ]] && write_val "Updating" "updated" || log "Value doesn't exist for $(full_key); nothing to do" && exit 0
    fi
done

